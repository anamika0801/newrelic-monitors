name: üöÄ Upsert/Delete New Relic Monitors and SLOs

on:
  # Allows manual trigger via the GitHub Actions UI
  workflow_dispatch:
  # Trigger on push to the main branch
  push:
    branches:
      - main
    paths:
      - 'monitor_details.json'
      - 'slo_details.json' # New SLO trigger
      - 'monitors/**.js'

# --- COMMON ENVIRONMENT ---
env:
  NR_ENDPOINT: https://api.newrelic.com/graphql
  NR_API_KEY: ${{ secrets.NEW_RELIC_API_KEY }}

jobs:
  # ------------------------------------------------------------------
  # --- JOBS 1 & 2: MONITOR CONFIGURATION (Existing Logic) ---
  # ------------------------------------------------------------------

  read_monitor_config:
    runs-on: ubuntu-latest
    outputs:
      config: ${{ steps.read_config_step.outputs.config }}

    steps:
      - name: ‚¨áÔ∏è Checkout Repository
        uses: actions/checkout@v4

      - name: üíæ Read Monitor Configuration File
        id: read_config_step
        run: echo "config=$(jq -c '.' monitor_details.json)" >> $GITHUB_OUTPUT

  manage_synthetics_monitors:
    needs: read_monitor_config
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        monitor: ${{ fromJson(needs.read_monitor_config.outputs.config) }}

    steps:
      - name: ‚¨áÔ∏è Checkout Repository
        uses: actions/checkout@v4
      
      - name: ‚öôÔ∏è Setup Monitor Environment and Get Script Content/Action
        # [Monitor setup logic retained and omitted for brevity, but it is identical to your original 'setup' step]
        # ... your existing setup logic to export monitor details and script content ...
        # (The full logic from your request will be included here)
        id: setup
        run: |
          CONFIG='${{ toJson(matrix.monitor) }}'
          MONITOR_GUID=$(echo "$CONFIG" | jq -r '.guid')
          ACCOUNT_ID=$(echo "$CONFIG" | jq -r '.accountId')
          NEW_STATUS=$(echo "$CONFIG" | jq -r '.monitorStatus')
          NEW_NAME=$(echo "$CONFIG" | jq -r '.monitorName')
          NEW_PERIOD=$(echo "$CONFIG" | jq -r '.monitorPeriod')
          SCRIPT_PATH=$(echo "$CONFIG" | jq -r '.scriptPath')
          MONITOR_ACTION=$(echo "$CONFIG" | jq -r '.action // "upsert"') 
          MONITOR_LOCATIONS_JSON=$(echo "$CONFIG" | jq -c '.monitorLocations') 
          
          MONITOR_SCRIPT_CONTENT=""
          if [ "$MONITOR_ACTION" == "upsert" ]; then
            if [ -f "$SCRIPT_PATH" ]; then
              MONITOR_SCRIPT_CONTENT=$(cat "$SCRIPT_PATH" | base64 | tr -d '\n')
            else
              echo "::error::Upsert requested, but script file not found at $SCRIPT_PATH"
              exit 1
            fi
          fi
          
          # Expose all variables for the next step (Base64 encoding done here)
          echo "monitor_guid=$MONITOR_GUID" >> $GITHUB_OUTPUT
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "new_status=$NEW_STATUS" >> $GITHUB_OUTPUT
          echo "new_name=$NEW_NAME" >> $GITHUB_OUTPUT
          echo "new_period=$NEW_PERIOD" >> $GITHUB_OUTPUT
          echo "monitor_action=$MONITOR_ACTION" >> $GITHUB_OUTPUT
          echo "script_content=$MONITOR_SCRIPT_CONTENT" >> $GITHUB_OUTPUT
          echo "locations_json=$MONITOR_LOCATIONS_JSON" >> $GITHUB_OUTPUT


      - name: üöÄ Execute New Relic Synthetics Mutation
        env:
          GUID: ${{ steps.setup.outputs.monitor_guid }}
          ACCOUNT_ID: ${{ steps.setup.outputs.account_id }}
          STATUS: ${{ steps.setup.outputs.new_status }}
          NAME: ${{ steps.setup.outputs.new_name }}
          PERIOD: ${{ steps.setup.outputs.new_period }}
          SCRIPT_CONTENT: ${{ steps.setup.outputs.script_content }}
          LOCATIONS_JSON: ${{ steps.setup.outputs.locations_json }}
          ACTION: ${{ steps.setup.outputs.monitor_action }}
        # [Monitor execution logic retained and omitted for brevity, but it is identical to your original 'execute' step]
        # (The full logic from your request will be included here)
        run: |
          MUTATION_PAYLOAD=""
          MUTATION_RESULT_PATH=""
          MONITOR_ERRORS_PATH=""

          if [ "$ACTION" == "delete" ]; then
              if [ -z "$GUID" ]; then
                  echo "::warning::Cannot delete monitor '$NAME': GUID is missing. Skipping deletion."
                  exit 0
              fi
              echo "Preparing DELETE mutation for monitor: $NAME (GUID: $GUID)"
              MUTATION_RESULT_PATH=".data.syntheticsDeleteMonitor"
              
              MUTATION_PAYLOAD=$(jq -n \
                  --arg guid "$GUID" \
                  '{
                      query: "mutation DeleteSyntheticMonitor($guid: EntityGuid!) { syntheticsDeleteMonitor(guid: $guid) { deletedGuid } }",
                      variables: {
                          guid: $guid
                      }
                  }')

          elif [ -z "$GUID" ]; then
              echo "Preparing CREATE mutation for monitor: $NAME"
              MUTATION_RESULT_PATH=".data.syntheticsCreateScriptApiMonitor"
              MONITOR_ERRORS_PATH=".data.syntheticsCreateScriptApiMonitor.errors"
              
              MUTATION_PAYLOAD=$(jq -n \
                --arg accountId "$ACCOUNT_ID" \
                --arg status "$STATUS" \
                --arg name "$NAME" \
                --arg period "$PERIOD" \
                --arg script_content "$SCRIPT_CONTENT" \
                --argjson locations "$LOCATIONS_JSON" \
                '{
                  query: "mutation CreateSyntheticMonitor($accountId: Int!, $monitorInput: SyntheticsCreateScriptApiMonitorInput!) { syntheticsCreateScriptApiMonitor(accountId: $accountId, monitor: $monitorInput) { errors { description type } monitor { guid name status } } }",
                  variables: {
                    accountId: ($accountId | tonumber),
                    monitorInput: {
                      status: $status,
                      name: $name,
                      period: $period,
                      script: $script_content,
                      locations: { public: $locations }
                    }
                  }
                }')
          else
              echo "Preparing UPDATE mutation for monitor: $NAME (GUID: $GUID)"
              MUTATION_RESULT_PATH=".data.syntheticsUpdateScriptApiMonitor"
              MONITOR_ERRORS_PATH=".data.syntheticsUpdateScriptApiMonitor.errors"

              MUTATION_PAYLOAD=$(jq -n \
                --arg guid "$GUID" \
                --arg status "$STATUS" \
                --arg name "$NAME" \
                --arg period "$PERIOD" \
                --arg script_content "$SCRIPT_CONTENT" \
                --argjson locations "$LOCATIONS_JSON" \
                '{
                  query: "mutation UpdateSyntheticMonitor($guid: EntityGuid!, $monitorInput: SyntheticsUpdateScriptApiMonitorInput!) { syntheticsUpdateScriptApiMonitor(guid: $guid, monitor: $monitorInput) { errors { description type } monitor { guid name status } } }",
                  variables: {
                    guid: $guid,
                    monitorInput: {
                      status: $status,
                      name: $name,
                      period: $period,
                      script: $script_content,
                      locations: { public: $locations }
                    }
                  }
                }')
          fi

          if [ -z "$MUTATION_PAYLOAD" ]; then echo "No mutation payload generated. Exiting."; exit 0; fi

          echo "Executing GraphQL mutation..."
          RESPONSE=$(curl -s -X POST "$NR_ENDPOINT" \
            -H "Content-Type: application/json" \
            -H "Api-Key: $NR_API_KEY" \
            --data-raw "$MUTATION_PAYLOAD")

          GLOBAL_ERRORS=$(echo "$RESPONSE" | jq -r '.errors')
          
          if [ "$ACTION" != "delete" ]; then
              ERROR_COUNT=$(echo "$RESPONSE" | jq -r "$MONITOR_ERRORS_PATH | length")
          fi
          
          NEW_GUID=$(echo "$RESPONSE" | jq -r ".data.syntheticsCreateScriptApiMonitor.monitor.guid // \"\"")

          if [ "$GLOBAL_ERRORS" != "null" ]; then
              echo "::error::Global GraphQL Error for monitor $NAME (Auth/Permission Issue likely)."
              echo "Global Error Details:"
              echo "$GLOBAL_ERRORS" | jq '.'
              exit 1
          fi

          if [ "$ACTION" != "delete" ] && [ "$ERROR_COUNT" -gt 0 ]; then
              echo "::error::Action ($ACTION) failed for monitor $NAME."
              echo "Mutation Error Details:"
              echo "$RESPONSE" | jq -r "$MONITOR_ERRORS_PATH"
              exit 1
          fi

          if [ "$ACTION" == "delete" ]; then
              echo "‚úÖ Monitor DELETED successfully. GUID: $GUID"
              echo "‚ö†Ô∏è ACTION REQUIRED: Remove this entry from 'monitor_details.json' completely."
          elif [ -z "$GUID" ]; then
              echo "‚úÖ Monitor CREATED successfully. New GUID: $NEW_GUID"
              echo "‚ö†Ô∏è IMPORTANT: Update 'monitor_details.json' with this new GUID for future updates."
          else
              echo "‚úÖ Monitor UPDATED successfully."
          fi

  # ------------------------------------------------------------------
  # --- JOBS 3 & 4: SERVICE LEVEL OBJECTIVE (SLO) CONFIGURATION (NEW LOGIC) ---
  # ------------------------------------------------------------------

  read_slo_config:
    runs-on: ubuntu-latest
    outputs:
      config: ${{ steps.read_config_step.outputs.config }}
    steps:
      - name: ‚¨áÔ∏è Checkout Repository
        uses: actions/checkout@v4
      - name: üíæ Read SLO Configuration File
        id: read_config_step
        run: echo "config=$(jq -c '.' slo_details.json)" >> $GITHUB_OUTPUT

  manage_service_levels:
    needs: read_slo_config
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        slo: ${{ fromJson(needs.read_slo_config.outputs.config) }}

    steps:
      - name: ‚öôÔ∏è Setup SLO Environment and Action
        id: setup
        run: |
          CONFIG='${{ toJson(matrix.slo) }}'
          GUID=$(echo "$CONFIG" | jq -r '.guid')
          ACCOUNT_ID=$(echo "$CONFIG" | jq -r '.accountId')
          SLO_NAME=$(echo "$CONFIG" | jq -r '.sloName')
          TARGET=$(echo "$CONFIG" | jq -r '.target')
          TIME_WINDOW=$(echo "$CONFIG" | jq -r '.timeWindow')
          ENTITY_GUID=$(echo "$CONFIG" | jq -r '.entityGuid')
          NRQL_EXPRESSION=$(echo "$CONFIG" | jq -r '.sliNrqlExpression')
          SLO_ACTION=$(echo "$CONFIG" | jq -r '.action // "upsert"')
          
          echo "slo_guid=$GUID" >> $GITHUB_OUTPUT
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "slo_name=$SLO_NAME" >> $GITHUB_OUTPUT
          echo "target=$TARGET" >> $GITHUB_OUTPUT
          echo "time_window=$TIME_WINDOW" >> $GITHUB_OUTPUT
          echo "entity_guid=$ENTITY_GUID" >> $GITHUB_OUTPUT
          echo "nrql_expression=$NRQL_EXPRESSION" >> $GITHUB_OUTPUT
          echo "slo_action=$SLO_ACTION" >> $GITHUB_OUTPUT

      - name: üöÄ Execute New Relic SLO Mutation
        env:
          GUID: ${{ steps.setup.outputs.slo_guid }}
          ACCOUNT_ID: ${{ steps.setup.outputs.account_id }}
          SLO_NAME: ${{ steps.setup.outputs.slo_name }}
          TARGET: ${{ steps.setup.outputs.target }}
          TIME_WINDOW: ${{ steps.setup.outputs.time_window }}
          ENTITY_GUID: ${{ steps.setup.outputs.entity_guid }}
          NRQL_EXPRESSION: ${{ steps.setup.outputs.nrql_expression }}
          ACTION: ${{ steps.setup.outputs.slo_action }}
        run: |
          MUTATION_PAYLOAD=""
          MUTATION_RESULT_PATH=""

          if [ "$ACTION" == "delete" ]; then
              if [ -z "$GUID" ]; then
                  echo "::warning::Cannot delete SLO '$SLO_NAME': GUID is missing. Skipping deletion."
                  exit 0
              fi
              echo "Preparing DELETE mutation for SLO: $SLO_NAME (GUID: $GUID)"
              MUTATION_RESULT_PATH=".data.serviceLevelDelete"
              
              MUTATION_PAYLOAD=$(jq -n \
                  --arg guid "$GUID" \
                  '{
                      query: "mutation DeleteServiceLevel($guid: EntityGuid!) { serviceLevelDelete(guid: $guid) { deletedGuid } }",
                      variables: {
                          guid: $guid
                      }
                  }')

          elif [ -z "$GUID" ]; then
              # --- CREATE PATH ---
              echo "Preparing CREATE mutation for SLO: $SLO_NAME"
              MUTATION_RESULT_PATH=".data.serviceLevelCreate"
              
              # Construct the SLI Input object (NRQL type)
              SLI_INPUT=$(jq -n \
                  --arg expression "$NRQL_EXPRESSION" \
                  --arg entityGuid "$ENTITY_GUID" \
                  '{ type: "NRQL", nrql: { query: $expression, entityGuid: $entityGuid } }')

              # Construct the main SLO Input object
              SLO_INPUT=$(jq -n \
                  --arg name "$SLO_NAME" \
                  --arg timeWindow "$TIME_WINDOW" \
                  --arg target "$TARGET" \
                  --argjson indicator "$SLI_INPUT" \
                  '{ name: $name, target: ($target | tonumber), timeWindow: $timeWindow, indicator: $indicator }')
              
              MUTATION_PAYLOAD=$(jq -n \
                --arg accountId "$ACCOUNT_ID" \
                --argjson sloInput "$SLO_INPUT" \
                '{
                  query: "mutation CreateServiceLevel($accountId: Int!, $sloInput: ServiceLevelCreateInput!) { serviceLevelCreate(accountId: $accountId, serviceLevel: $sloInput) { serviceLevel { guid } } }",
                  variables: { accountId: ($accountId | tonumber), sloInput: $sloInput }
                }')
          else
              # --- UPDATE PATH ---
              echo "Preparing UPDATE mutation for SLO: $SLO_NAME (GUID: $GUID)"
              MUTATION_RESULT_PATH=".data.serviceLevelUpdate"

              # Construct the SLI Input object (NRQL type)
              SLI_INPUT=$(jq -n \
                  --arg expression "$NRQL_EXPRESSION" \
                  --arg entityGuid "$ENTITY_GUID" \
                  '{ type: "NRQL", nrql: { query: $expression, entityGuid: $entityGuid } }')

              # Construct the main SLO Input object
              SLO_INPUT=$(jq -n \
                  --arg name "$SLO_NAME" \
                  --arg timeWindow "$TIME_WINDOW" \
                  --arg target "$TARGET" \
                  --argjson indicator "$SLI_INPUT" \
                  '{ name: $name, target: ($target | tonumber), timeWindow: $timeWindow, indicator: $indicator }')

              MUTATION_PAYLOAD=$(jq -n \
                --arg guid "$GUID" \
                --argjson sloInput "$SLO_INPUT" \
                '{
                  query: "mutation UpdateServiceLevel($guid: EntityGuid!, $sloInput: ServiceLevelUpdateInput!) { serviceLevelUpdate(guid: $guid, serviceLevel: $sloInput) { serviceLevel { guid } } }",
                  variables: { guid: $guid, sloInput: $sloInput }
                }')
          fi

          if [ -z "$MUTATION_PAYLOAD" ]; then echo "No SLO mutation payload generated. Exiting."; exit 0; fi

          echo "Executing GraphQL mutation..."
          RESPONSE=$(curl -s -X POST "$NR_ENDPOINT" \
            -H "Content-Type: application/json" \
            -H "Api-Key: $NR_API_KEY" \
            --data-raw "$MUTATION_PAYLOAD")

          GLOBAL_ERRORS=$(echo "$RESPONSE" | jq -r '.errors')
          NEW_GUID=$(echo "$RESPONSE" | jq -r ".data.serviceLevelCreate.serviceLevel.guid // .data.serviceLevelUpdate.serviceLevel.guid // \"\"")

          if [ "$GLOBAL_ERRORS" != "null" ]; then
              echo "::error::Global GraphQL Error for SLO $SLO_NAME (Auth/Permission Issue likely)."
              echo "Global Error Details:"
              echo "$GLOBAL_ERRORS" | jq '.'
              exit 1
          fi
          
          if [ "$ACTION" == "delete" ]; then
              echo "‚úÖ SLO DELETED successfully. GUID: $GUID"
              echo "‚ö†Ô∏è ACTION REQUIRED: Remove this entry from 'slo_details.json' completely."
          elif [ -z "$GUID" ]; then
              echo "‚úÖ SLO CREATED successfully. New GUID: $NEW_GUID"
              echo "‚ö†Ô∏è IMPORTANT: Update 'slo_details.json' with this new GUID for future updates."
          else
              echo "‚úÖ SLO UPDATED successfully."
          fi
