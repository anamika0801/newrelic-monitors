name: üöÄ Upsert New Relic Synthetics Monitors

on:
  # Allows manual trigger via the GitHub Actions UI
  workflow_dispatch:
  # Trigger on push to the main branch
  push:
    branches:
      - main
    paths:
      - 'monitor_details.json'
      - 'monitors/**.js'

jobs:
  # --- JOB 1: Read the configuration file ---
  read_config:
    runs-on: ubuntu-latest
    outputs:
      # Expose the content of monitor_details.json as a job output
      config: ${{ steps.read_config_step.outputs.config }}

    steps:
      - name: ‚¨áÔ∏è Checkout Repository
        uses: actions/checkout@v4

      - name: üíæ Read Monitor Configuration File
        id: read_config_step
        # Use 'jq -c .' to ensure the JSON content is a single, compact line
        run: echo "config=$(jq -c '.' monitor_details.json)" >> $GITHUB_OUTPUT

  # --- JOB 2: Iterate and perform the upsert operation ---
  upsert_monitors:
    # This job MUST wait for 'read_config' to finish
    needs: read_config
    runs-on: ubuntu-latest

    # Use the output from the first job to define the matrix
    strategy:
      fail-fast: false
      matrix:
        # The configuration is now accessed via 'needs.<job_id>.outputs.<output_name>'
        monitor: ${{ fromJson(needs.read_config.outputs.config) }}

    steps:
      - name: ‚¨áÔ∏è Checkout Repository
        uses: actions/checkout@v4
        
      - name: ‚öôÔ∏è Setup Environment and Get Script Content
        id: setup
        # Set up variables for the current monitor in the matrix
        run: |
          # Parse config variables from the matrix item
          CONFIG='${{ toJson(matrix.monitor) }}'
          MONITOR_GUID=$(echo "$CONFIG" | jq -r '.guid')
          ACCOUNT_ID=$(echo "$CONFIG" | jq -r '.accountId')
          NEW_STATUS=$(echo "$CONFIG" | jq -r '.monitorStatus')
          NEW_NAME=$(echo "$CONFIG" | jq -r '.monitorName')
          NEW_PERIOD=$(echo "$CONFIG" | jq -r '.monitorPeriod')
          SCRIPT_PATH=$(echo "$CONFIG" | jq -r '.scriptPath')
          
          # Extract the locations array as a raw JSON string for insertion into the mutation
          MONITOR_LOCATIONS_JSON=$(echo "$CONFIG" | jq -c '.monitorLocations') 
          
          # Read the script file content (NO BASE64 ENCODING)
          MONITOR_SCRIPT_CONTENT=$(cat "$SCRIPT_PATH")
          
          # Expose all variables for the next step
          echo "monitor_guid=$MONITOR_GUID" >> $GITHUB_OUTPUT
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "new_status=$NEW_STATUS" >> $GITHUB_OUTPUT
          echo "new_name=$NEW_NAME" >> $GITHUB_OUTPUT
          echo "new_period=$NEW_PERIOD" >> $GITHUB_OUTPUT
          echo "script_content=$MONITOR_SCRIPT_CONTENT" >> $GITHUB_OUTPUT # Renamed variable
          echo "locations_json=$MONITOR_LOCATIONS_JSON" >> $GITHUB_OUTPUT

      - name: üöÄ Execute New Relic Upsert Mutation
        env:
          # Use the New Relic API Key secret for authentication
          NEW_RELIC_API_KEY: ${{ secrets.NEW_RELIC_API_KEY }}
          GUID: ${{ steps.setup.outputs.monitor_guid }}
          ACCOUNT_ID: ${{ steps.setup.outputs.account_id }}
          STATUS: ${{ steps.setup.outputs.new_status }}
          NAME: ${{ steps.setup.outputs.new_name }}
          PERIOD: ${{ steps.setup.outputs.new_period }}
          SCRIPT_CONTENT: ${{ steps.setup.outputs.script_content }} # Renamed variable
          LOCATIONS_JSON: ${{ steps.setup.outputs.locations_json }}
        run: |
          # Variable to hold the JSON payload
          MUTATION_PAYLOAD=""
          
          # Paths to extract data/errors from the final response
          MUTATION_RESULT_PATH=""
          MONITOR_ERRORS_PATH=""

          if [ -z "$GUID" ]; then
              # --- CREATE PATH: GUID is empty, use the CREATE mutation ---
              echo "Preparing CREATE mutation for monitor: $NAME"
              MUTATION_RESULT_PATH=".data.syntheticsCreateScriptApiMonitor"
              MONITOR_ERRORS_PATH=".data.syntheticsCreateScriptApiMonitor.errors"
              
              MUTATION_PAYLOAD=$(jq -n \
                --arg accountId "$ACCOUNT_ID" \
                --arg status "$STATUS" \
                --arg name "$NAME" \
                --arg period "$PERIOD" \
                --arg script_content "$SCRIPT_CONTENT" \
                --argjson locations "$LOCATIONS_JSON" \
                '{
                  query: "mutation CreateSyntheticMonitor($accountId: Int!, $monitorInput: SyntheticsCreateScriptApiMonitorInput!) {\n  syntheticsCreateScriptApiMonitor(\n    accountId: $accountId\n    monitor: $monitorInput\n  ) {\n    errors {\n      description\n      type\n    }\n    monitor {\n      guid\n      name\n      status\n    }\n  }\n}",
                  variables: {
                    accountId: ($accountId | tonumber),
                    monitorInput: {
                      status: $status,
                      name: $name,
                      period: $period,
                      script: $script_content, # Using raw content
                      locations: {
                        public: $locations
                      }
                    }
                  }
                }')
          else
              # --- UPDATE PATH: GUID is present, use the UPDATE mutation ---
              echo "Preparing UPDATE mutation for monitor: $NAME (GUID: $GUID)"
              MUTATION_RESULT_PATH=".data.syntheticsUpdateScriptApiMonitor"
              MONITOR_ERRORS_PATH=".data.syntheticsUpdateScriptApiMonitor.errors"

              MUTATION_PAYLOAD=$(jq -n \
                --arg guid "$GUID" \
                --arg status "$STATUS" \
                --arg name "$NAME" \
                --arg period "$PERIOD" \
                --arg script_content "$SCRIPT_CONTENT" \
                --argjson locations "$LOCATIONS_JSON" \
                '{
                  # NOTE: Update mutation does not take $accountId, and $guid requires EntityGuid! type
                  query: "mutation UpdateSyntheticMonitor($guid: EntityGuid!, $monitorInput: SyntheticsUpdateScriptApiMonitorInput!) {\n  syntheticsUpdateScriptApiMonitor(\n    guid: $guid\n    monitor: $monitorInput\n  ) {\n    errors {\n      description\n      type\n    }\n    monitor {\n      guid\n      name\n      status\n    }\n  }\n}",
                  variables: {
                    guid: $guid,
                    monitorInput: {
                      status: $status,
                      name: $name,
                      period: $period,
                      script: $script_content, # Using raw content
                      locations: {
                        public: $locations
                      }
                    }
                  }
                }')
          fi

          # 2. Execute the Mutation via curl
          echo "Executing GraphQL mutation..."
          RESPONSE=$(curl -s -X POST 'https://api.newrelic.com/graphql' \
            -H "Content-Type: application/json" \
            -H "Api-Key: $NEW_RELIC_API_KEY" \
            --data-raw "$MUTATION_PAYLOAD")

          # 3. Process the Response - Check for global errors first
          GLOBAL_ERRORS=$(echo "$RESPONSE" | jq -r '.errors')
          # Check the length of the error array for mutation-specific errors
          ERROR_COUNT=$(echo "$RESPONSE" | jq -r "$MONITOR_ERRORS_PATH | length")
          NEW_GUID=$(echo "$RESPONSE" | jq -r "$MUTATION_RESULT_PATH.monitor.guid")
          
          # Check for root-level GraphQL errors (often permission/auth issues)
          if [ "$GLOBAL_ERRORS" != "null" ]; then
              echo "::error::Global GraphQL Error for monitor $NAME (Auth/Permission Issue likely)."
              echo "Global Error Details:"
              echo "$GLOBAL_ERRORS" | jq '.'
              exit 1
          fi

          # Check for mutation-specific errors (if the count > 0)
          if [ "$ERROR_COUNT" -gt 0 ]; then
              echo "::error::Upsert failed for monitor $NAME."
              echo "Mutation Error Details:"
              # Print the actual error details from the response
              echo "$RESPONSE" | jq -r "$MONITOR_ERRORS_PATH"
              exit 1
          fi

          if [ -z "$GUID" ]; then
              echo "‚úÖ Monitor CREATED successfully. New GUID: $NEW_GUID"
              echo "‚ö†Ô∏è IMPORTANT: Update 'monitor_details.json' with this new GUID for future updates."
          else
              echo "‚úÖ Monitor UPDATED successfully."
          fi
