name: 🚀 Upsert/Delete New Relic Synthetics Monitors

on:
  # Allows manual trigger via the GitHub Actions UI
  workflow_dispatch:
  # Trigger on push to the main branch
  push:
    branches:
      - main
    paths:
      - 'monitor_details.json'
      - 'monitors/**.js'

jobs:
  # --- JOB 1: Read the configuration file ---
  read_config:
    runs-on: ubuntu-latest
    outputs:
      # Expose the content of monitor_details.json as a job output
      config: ${{ steps.read_config_step.outputs.config }}

    steps:
      - name: ⬇️ Checkout Repository
        uses: actions/checkout@v4

      - name: 💾 Read Monitor Configuration File
        id: read_config_step
        # Use 'jq -c .' to ensure the JSON content is a single, compact line
        run: echo "config=$(jq -c '.' monitor_details.json)" >> $GITHUB_OUTPUT

  # --- JOB 2: Iterate and perform the upsert/delete operation ---
  manage_monitors: # Renamed job for clarity
    # This job MUST wait for 'read_config' to finish
    needs: read_config
    runs-on: ubuntu-latest

    # Use the output from the first job to define the matrix
    strategy:
      fail-fast: false
      matrix:
        # The configuration is now accessed via 'needs.<job_id>.outputs.<output_name>'
        monitor: ${{ fromJson(needs.read_config.outputs.config) }}

    steps:
      - name: ⬇️ Checkout Repository
        uses: actions/checkout@v4
        
      - name: ⚙️ Setup Environment and Get Script Content/Action
        id: setup
        # Set up variables for the current monitor in the matrix
        run: |
          # Parse config variables from the matrix item
          CONFIG='${{ toJson(matrix.monitor) }}'
          MONITOR_GUID=$(echo "$CONFIG" | jq -r '.guid')
          ACCOUNT_ID=$(echo "$CONFIG" | jq -r '.accountId')
          NEW_STATUS=$(echo "$CONFIG" | jq -r '.monitorStatus')
          NEW_NAME=$(echo "$CONFIG" | jq -r '.monitorName')
          NEW_PERIOD=$(echo "$CONFIG" | jq -r '.monitorPeriod')
          SCRIPT_PATH=$(echo "$CONFIG" | jq -r '.scriptPath')
          # --- ADDED: Read the action, default to 'upsert' ---
          MONITOR_ACTION=$(echo "$CONFIG" | jq -r '.action // "upsert"') 
          
          # Extract the locations array as a raw JSON string for insertion into the mutation
          MONITOR_LOCATIONS_JSON=$(echo "$CONFIG" | jq -c '.monitorLocations')  
          
          # Read the script file content ONLY IF it's an upsert action
          MONITOR_SCRIPT_CONTENT=""
          if [ "$MONITOR_ACTION" == "upsert" ]; then
            if [ -f "$SCRIPT_PATH" ]; then
              MONITOR_SCRIPT_CONTENT=$(cat "$SCRIPT_PATH")
            else
              echo "::error::Upsert requested, but script file not found at $SCRIPT_PATH"
              exit 1
            fi
          fi
          
          # Expose all variables for the next step
          echo "monitor_guid=$MONITOR_GUID" >> $GITHUB_OUTPUT
          echo "account_id=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "new_status=$NEW_STATUS" >> $GITHUB_OUTPUT
          echo "new_name=$NEW_NAME" >> $GITHUB_OUTPUT
          echo "new_period=$NEW_PERIOD" >> $GITHUB_OUTPUT
          echo "monitor_action=$MONITOR_ACTION" >> $GITHUB_OUTPUT # <-- EXPOSE ACTION
          
          # Use multi-line output syntax for the script content
          echo "script_content<<EOD" >> $GITHUB_OUTPUT
          echo "$MONITOR_SCRIPT_CONTENT" >> $GITHUB_OUTPUT
          echo "EOD" >> $GITHUB_OUTPUT

          echo "locations_json=$MONITOR_LOCATIONS_JSON" >> $GITHUB_OUTPUT

      - name: 🚀 Execute New Relic Upsert/Delete Mutation
        env:
          # Use the New Relic API Key secret for authentication
          NEW_RELIC_API_KEY: ${{ secrets.NEW_RELIC_API_KEY }}
          GUID: ${{ steps.setup.outputs.monitor_guid }}
          ACCOUNT_ID: ${{ steps.setup.outputs.account_id }}
          STATUS: ${{ steps.setup.outputs.new_status }}
          NAME: ${{ steps.setup.outputs.new_name }}
          PERIOD: ${{ steps.setup.outputs.new_period }}
          SCRIPT_CONTENT: ${{ steps.setup.outputs.script_content }}
          LOCATIONS_JSON: ${{ steps.setup.outputs.locations_json }}
          ACTION: ${{ steps.setup.outputs.monitor_action }} # <-- USE ACTION
        run: |
          # Variable to hold the JSON payload
          MUTATION_PAYLOAD=""
          # Paths to extract data/errors from the final response
          MUTATION_RESULT_PATH=""
          MONITOR_ERRORS_PATH=""

          if [ "$ACTION" == "delete" ]; then # --- DELETE PATH: ACTION is delete ---
              if [ -z "$GUID" ]; then
                  echo "::warning::Cannot delete monitor '$NAME': GUID is missing. Skipping deletion."
                  exit 0
              fi

              echo "Preparing DELETE mutation for monitor: $NAME (GUID: $GUID)"
              MUTATION_RESULT_PATH=".data.syntheticsDeleteMonitor"
              MONITOR_ERRORS_PATH=".data.syntheticsDeleteMonitor.errors"

              # **UPDATED: Removed 'errors' field from the query body**
              MUTATION_PAYLOAD=$(jq -n \
                  --arg guid "$GUID" \
                  '{
                      query: "mutation DeleteSyntheticMonitor($guid: EntityGuid!) {\n  syntheticsDeleteMonitor(\n    guid: $guid\n  ) {\n    deletedGuid\n  }\n}",
                      variables: {
                          guid: $guid
                      }
                  }')

          elif [ -z "$GUID" ]; then
              # --- CREATE PATH: GUID is empty, use the CREATE mutation ---
              echo "Preparing CREATE mutation for monitor: $NAME"
              MUTATION_RESULT_PATH=".data.syntheticsCreateScriptApiMonitor"
              MONITOR_ERRORS_PATH=".data.syntheticsCreateScriptApiMonitor.errors"
              
              # Original CREATE payload logic
              MUTATION_PAYLOAD=$(jq -n \
                --arg accountId "$ACCOUNT_ID" \
                --arg status "$STATUS" \
                --arg name "$NAME" \
                --arg period "$PERIOD" \
                --arg script_content "$SCRIPT_CONTENT" \
                --argjson locations "$LOCATIONS_JSON" \
                '{
                  query: "mutation CreateSyntheticMonitor($accountId: Int!, $monitorInput: SyntheticsCreateScriptApiMonitorInput!) {\n  syntheticsCreateScriptApiMonitor(\n    accountId: $accountId\n    monitor: $monitorInput\n  ) {\n    errors {\n      description\n      type\n    }\n    monitor {\n      guid\n      name\n      status\n    }\n  }\n}",
                  variables: {
                    accountId: ($accountId | tonumber),
                    monitorInput: {
                      status: $status,
                      name: $name,
                      period: $period,
                      script: $script_content,
                      locations: {
                        public: $locations
                      }
                    }
                  }
                }')
          else
              # --- UPDATE PATH: GUID is present, use the UPDATE mutation ---
              echo "Preparing UPDATE mutation for monitor: $NAME (GUID: $GUID)"
              MUTATION_RESULT_PATH=".data.syntheticsUpdateScriptApiMonitor"
              MONITOR_ERRORS_PATH=".data.syntheticsUpdateScriptApiMonitor.errors"

              # Original UPDATE payload logic
              MUTATION_PAYLOAD=$(jq -n \
                --arg guid "$GUID" \
                --arg status "$STATUS" \
                --arg name "$NAME" \
                --arg period "$PERIOD" \
                --arg script_content "$SCRIPT_CONTENT" \
                --argjson locations "$LOCATIONS_JSON" \
                '{
                  query: "mutation UpdateSyntheticMonitor($guid: EntityGuid!, $monitorInput: SyntheticsUpdateScriptApiMonitorInput!) {\n  syntheticsUpdateScriptApiMonitor(\n    guid: $guid\n    monitor: $monitorInput\n  ) {\n    errors {\n      description\n      type\n    }\n    monitor {\n      guid\n      name\n      status\n    }\n  }\n}",
                  variables: {
                    guid: $guid,
                    monitorInput: {
                      status: $status,
                      name: $name,
                      period: $period,
                      script: $script_content,
                      locations: {
                        public: $locations
                      }
                    }
                  }
                }')
          fi

          # Skip curl if no action was taken (e.g., GUID missing for deletion)
          if [ -z "$MUTATION_PAYLOAD" ]; then
            echo "No mutation payload generated. Exiting."
            exit 0
          fi

          # 2. Execute the Mutation via curl
          echo "Executing GraphQL mutation..."
          RESPONSE=$(curl -s -X POST 'https://api.newrelic.com/graphql' \
            -H "Content-Type: application/json" \
            -H "Api-Key: $NEW_RELIC_API_KEY" \
            --data-raw "$MUTATION_PAYLOAD")

          # 3. Process the Response - Check for global errors first
          GLOBAL_ERRORS=$(echo "$RESPONSE" | jq -r '.errors')
          # Check the length of the error array for mutation-specific errors
          # Note: Delete mutation returns 'deletedGuid' on success, not a monitor object.
          ERROR_COUNT=0
          if [ "$ACTION" != "delete" ]; then
              ERROR_COUNT=$(echo "$RESPONSE" | jq -r "$MONITOR_ERRORS_PATH | length")
          elif [ "$ACTION" == "delete" ]; then
              # For deletion, check if the deletedGuid is null (which might indicate an error) or if errors are present
              DELETED_GUID=$(echo "$RESPONSE" | jq -r "$MUTATION_RESULT_PATH.deletedGuid")
              
              # Since the errors field was removed from the query, we can't reliably check ERROR_COUNT > 0 
              # for deletion-specific errors. We rely on the global error check and the DELETED_GUID being null.
              if [ "$DELETED_GUID" == "null" ]; then
                # This catches cases where the monitor wasn't found or API failed silently (Permissions issue).
                echo "::warning::Deletion result GUID was null. Monitor $GUID may not have existed or API failed."
                # We exit 0 (Success) here to allow the process to continue, assuming non-existence 
                # is the reason for the null result, but it will no longer show detailed API errors 
                # specific to the deletion mutation result.
                exit 0
              fi
          fi
          
          NEW_GUID=$(echo "$RESPONSE" | jq -r ".data.syntheticsCreateScriptApiMonitor.monitor.guid // \"\"") # Only populated on CREATE

          # Check for root-level GraphQL errors (often permission/auth issues)
          if [ "$GLOBAL_ERRORS" != "null" ]; then
              echo "::error::Global GraphQL Error for monitor $NAME (Auth/Permission Issue likely)."
              echo "Global Error Details:"
              echo "$GLOBAL_ERRORS" | jq '.'
              exit 1
          fi

          # Check for mutation-specific errors (if the count > 0)
          if [ "$ACTION" != "delete" ] && [ "$ERROR_COUNT" -gt 0 ]; then
              echo "::error::Action ($ACTION) failed for monitor $NAME."
              echo "Mutation Error Details:"
              # Print the actual error details from the response
              echo "$RESPONSE" | jq -r "$MONITOR_ERRORS_PATH"
              exit 1
          fi

          # --- SUCCESS MESSAGES ---
          if [ "$ACTION" == "delete" ]; then
              echo "✅ Monitor DELETED successfully. GUID: $GUID"
              echo "⚠️ ACTION REQUIRED: Remove this entry from 'monitor_details.json' completely to prevent future deletion attempts."
          elif [ -z "$GUID" ]; then
              echo "✅ Monitor CREATED successfully. New GUID: $NEW_GUID"
              echo "⚠️ IMPORTANT: Update 'monitor_details.json' with this new GUID for future updates."
          else
              echo "✅ Monitor UPDATED successfully."
          fi
